/*global describe, it, beforeEach, before, afterEach, after*/
/*jshint expr:true*/
'use strict';

var fetchMock = (typeof window === 'undefined') ? require('fetch-mock') : require('fetch-mock/client');

var sinon = require('sinon');
require('es6-promise').polyfill();
require('isomorphic-fetch');

var Flags = require('../lib/flags');
var Flag = require('../lib/flag');
var expect  = require("chai").expect;

describe('Flags', function(){
	before(function () {
		fetchMock.registerRoute({
			name: 'flags',
			matcher: 'http://host.com/path.json',
			response: require('./fixtures/some-flags.js')
		});
	});

	beforeEach(function() {
		fetchMock.mock();
	});

	afterEach(function() {
		fetchMock.restore();
	});

	after(function () {
		fetchMock.unregisterRoute();
	});

	it('should allow no url', function() {
		expect(function () {
			new Flags().init();
		}).not.to.throw();
	});

	it('should initialize with polling', function(done) {
		var flags = new Flags();
		return flags.init({
			url: 'http://host.com/path.json',
			timeout: 10,
			interval: 100
		})
			.then(function() {
				expect(flags.get('contextNavigation')).to.be.false;
				expect(flags.get('video')).to.be.true;
				fetchMock.reMock({
					responses: {
						flags: require('./fixtures/some-other-flags.js')
					}
				});
				setTimeout(function () {
					expect(flags.get('contextNavigation')).to.be.true;
					expect(flags.get('video')).to.be.false;
					done();
				}, 101);
			});
	});

	it('should initialize with set of flags without polling', function(done) {
		var flags = new Flags({flags: require('./fixtures/some-flags.js')});
		sinon.spy(flags, 'update');
		return flags.init()
			.then(function () {
				expect(flags.get('contextNavigation')).to.be.false;
				expect(flags.get('video')).to.be.true;
				expect(flags.update.called).to.be.false;
				flags.update.restore();
				done();
			});
	});

	describe('obtaining flag values', function () {
		var flags;
		beforeEach(function () {
			flags = new Flags({flags: require('./fixtures/some-flags.js')});
		});

		it('should get hash of flag truthinesses', function () {
			expect(flags.getHash()).to.eql({
					contextNavigation: false,
					longExpired: false,
					recentlyExpired: false,
					video: true
			});
		});

		it('should get all flags', function () {
			var allFlags = flags.get();
			expect(allFlags.video instanceof Flag).to.be.true;
		});

		it('should expose raw flag data as an array', function () {
			expect(flags.flagsArray instanceof Array).to.be.true;
		});

	});

	describe('tech debt alerting', function () {
		it('should be alerted when long expired flags are still in use', function() {
			var alerter = sinon.spy();
			var flags = new Flags({
				alerter: alerter,
				flags: require('./fixtures/some-flags.js')
			});
			flags.get('longExpired');
			expect(alerter.calledOnce).to.be.true;
			expect(alerter.firstCall.args[0].name).to.equal('longExpired');
		});

		it('should be \'off\'y (similar to falsey) for flags that don\'t exist', function() {
			var alerter = sinon.spy();
			var flags = new Flags({
				alerter: alerter,
				flags: require('./fixtures/some-flags.js')
			});
			expect(flags.get('notAFlag')).to.be.false;
			expect(alerter.calledOnce).to.be.true;
			expect(alerter.firstCall.args[0].name).to.equal('notAFlag (unknown)');
		});
	});
});
