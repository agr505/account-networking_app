
'use strict';

var Flag = require('./flag');

var Flags = function (opts) {
	opts = opts || {};
	this.overrides = opts.overrides || {};

	this.techDebtAlerter = opts.alerter || function () {};
	if (opts.flags) {
		this.set(opts.flags);
	} else {
		this.flags = {};
	}
};

Flags.prototype.init = function (options) {
	options = options || {};

	if (!this._initPromise) {

		if (typeof options.url === 'string') {
			this.url = options.url;
			this.timeout = options.timeout || 3000;
			this.interval = options.interval || 30000;
			this._initPromise = this.update();
			// don't throw errors if polling fails
			this.poller = setInterval(this.update.bind(this, { suppressTimeoutErrors: true }), this.interval);
		} else {
			this._initPromise = Promise.resolve();
		}
	}

	return this._initPromise;
};

Flags.prototype.update = function (opts) {
	var fetcher = this.eagerFetch && !this._initPromise ? this.eagerFetch : fetch;

	return fetcher(this.url, {
		timeout: this.timeout
	})
		.then(function(response) {
			if (response.status >= 400) throw new Error("Bad response from flags request");
			return response.json();
		})
		.then(function(data) {
			this.set(data);
		}.bind(this))
		.catch(function(err) {
			if (opts && opts.suppressTimeoutErrors && err.message.indexOf('network timeout at') > -1) {
				return;
			}
			setTimeout(function () {throw err}, 0);
		});

};

Flags.prototype.get = function (flagname) {

	var flag;

	if (flagname) {
		flag = this.flags[flagname];

		if (!flag) {
			flag = new Flag({
				name: flagname + ' (unknown)',
				description: 'unknown',
				safeState: false,
				expiry: 0
			});
			this.techDebtAlerter(flag);
		}
		return flag.isSwitchedOn ? true : false;
	}
	return this.flags;
};

Flags.prototype.getHash = function () {
	var hash = {};
	Object.keys(this.flags).forEach(function(key) {
		hash[key] = this.flags[key].isSwitchedOn;
	}.bind(this));
	return hash;
};

Flags.prototype.set = function (data) {

	var flags = {};

	if (!data || data.length === 0) {
		throw 'No data passed to initialise flags';
	}
	data.forEach(function(flag) {

		flag = new Flag(flag, {
			override: this.overrides[flag.name]
		});

		if (Object.defineProperty) {
			Object.defineProperty(flags, flag.name, {
				get: function () {
					this.techDebtAlerter(flag);
					return flag;
				}.bind(this),
				enumerable: true
			});
		} else {
			flags[flag.name] = flag;
		}

	}.bind(this));

	this.flags = flags;
	this.flagsArray = data.map(function (flag) {
		delete flag.owner;
		delete flag.description;
		if (flag.tags) {
			delete flag.tags;
		}
		if (flag.incubating) {
			delete flag.incubating;
		}
		return flag;
	});

	return this;
};

module.exports = Flags;
